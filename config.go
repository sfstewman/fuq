package fuq

import (
	"bufio"
	"bytes"
	"crypto/rand"
	"encoding/base64"
	"errors"
	"fmt"
	"io"
	"log"
	"os"
	"os/user"
	"path/filepath"
	"strconv"
	"strings"
	"time"
)

const (
	DefaultSystemConfigFile = "fuq.conf"
	DefaultServerConfigFile = "fuqsrv.conf"
	DefaultConfigPath       = ".fuq"
	DefaultDbFile           = "queue.db"
	DefaultPort             = 5429

	DefaultKeyFile    = "fuq.key"
	DefaultCertFile   = "fuq.crt"
	DefaultRootCAFile = "root.crt"

	CfgDirPerms  = 0700
	CfgFilePerms = 0600
)

type Config struct {
	DbPath  string
	LogDir  string
	Auth    string
	Foreman string
	Port    int

	ForemanLogFile string

	CertName string // server name in TLS certificate

	KeyFile    string
	CertFile   string
	RootCAFile string
}

func (c Config) CheckAuth(cred string) bool {
	return cred == c.Auth
}

func (c Config) CheckClient(client Client) bool {
	return c.CheckAuth(client.Password)
}

func (c *Config) SetupTLS(tlsDir string) {
	if c.KeyFile == "" {
		c.KeyFile = filepath.Join(tlsDir, DefaultKeyFile)
	}

	if c.CertFile == "" {
		c.CertFile = filepath.Join(tlsDir, DefaultCertFile)
	}

	if c.RootCAFile == "" {
		c.RootCAFile = filepath.Join(tlsDir, DefaultRootCAFile)
	}
}

func DefaultConfigDir(u *user.User) string {
	return filepath.Join(u.HomeDir, DefaultConfigPath)
}

func (c *Config) WriteConfig(w io.Writer) (int64, error) {
	b := bytes.Buffer{}
	fmt.Fprintf(&b, "# Autogenerated fuq server configuration file\n")
	fmt.Fprintf(&b, "# Generated on: %s\n#\n", time.Now())
	fmt.Fprintf(&b, "# DO NOT EDIT BY HAND.  Well, unless you know what you're doing.\n")
	fmt.Fprintf(&b, "#\n# NO, SERIOUSLY.  STOP.\n\n")
	fmt.Fprintf(&b, "foreman %s\n", c.Foreman)
	fmt.Fprintf(&b, "port %d\n", c.Port)
	fmt.Fprintf(&b, "logdir %s\n", c.LogDir)
	fmt.Fprintf(&b, "dbpath %s\n", c.DbPath)
	fmt.Fprintf(&b, "auth %s\n", c.Auth)

	if c.CertName != "" {
		fmt.Fprintf(&b, "certname %s\n", c.CertName)
	}

	n, err := io.Copy(w, &b)
	if err != nil {
		return n, fmt.Errorf("error writing config file to disk: %v", err)
	}

	return n, nil
}

func parseForemanAddr(addr string) (string, error) {
	// Rules for the foreman address:
	//   1) if prefixed with '!', use the rest, so "!foo" uses "foo"
	//   2) if "localhost", then use "localhost"
	//   3) otherwise use the hostname
	if addr == "localhost" {
		return addr, nil
	}

	if len(addr) > 1 && addr[0] == '!' {
		return addr[1:], nil
	}

	hostname, err := os.Hostname()
	if err != nil {
		return "", err
	}

	return hostname, nil
}

func (c *Config) GenerateConfigFile(fname string, pv *PathVars, overwrite bool) error {
	flags := os.O_RDWR | os.O_CREATE
	if !overwrite {
		flags = flags | os.O_EXCL
	}

	f, err := os.OpenFile(fname, flags, CfgFilePerms)
	if err != nil {
		if os.IsExist(err) && !overwrite {
			return c.ReadConfigFile(fname, pv)
		}

		if !os.IsNotExist(err) {
			return err
		}

		cfgDir := filepath.Dir(fname)
		if err := os.MkdirAll(cfgDir, CfgDirPerms); err != nil {
			return fmt.Errorf("error generating config file: %v", err)
		}

		f, err = os.OpenFile(fname, flags, CfgFilePerms)
		if err != nil {
			return fmt.Errorf("error generating config file: %v", err)
		}
	}
	defer f.Close()

	u, err := user.Current()
	if err != nil {
		return fmt.Errorf("error generating config file: %v", err)
	}

	c.Foreman, err = parseForemanAddr(c.Foreman)
	if err != nil {
		return fmt.Errorf("error generating foreman address in config file: %v", err)
	}

	if c.Port == 0 {
		c.Port = DefaultPort
	}

	cfgDir := DefaultConfigDir(u)

	if c.DbPath == "" {
		c.DbPath = filepath.Join(cfgDir, DefaultDbFile)
		if err := os.MkdirAll(cfgDir, CfgDirPerms); err != nil {
			return fmt.Errorf("error generating config directory '%s': %v",
				cfgDir, err)
		}
	}

	if c.LogDir == "" {
		c.LogDir = filepath.Join(cfgDir, "logs")
	}

	if err := os.MkdirAll(c.LogDir, CfgDirPerms); err != nil {
		return fmt.Errorf("error generating log directory '%s': %v",
			c.LogDir, err)
	}

	if c.Auth == "" {
		buf := [32]byte{}
		if _, err := rand.Read(buf[:]); err != nil {
			return fmt.Errorf("error generating auth string for config file: %s", err)
		}

		c.Auth = base64.RawStdEncoding.EncodeToString(buf[:])
	}

	if _, err := c.WriteConfig(f); err != nil {
		return err
	}

	return nil
}

func DefaultServerConfigPath() string {
	u, err := user.Current()
	if err != nil {
		return ""
	}

	return filepath.Join(u.HomeDir, DefaultConfigPath, DefaultServerConfigFile)
}

func DefaultSystemConfigPath() string {
	u, err := user.Current()
	if err != nil {
		return ""
	}

	return filepath.Join(u.HomeDir, DefaultConfigPath, DefaultSystemConfigFile)
}

type PathVars struct {
	Current string
	Home    string
	Other   map[string]string
}

func NewPathVars(curr, home string) *PathVars {
	return &PathVars{
		Current: curr,
		Home:    home,
		Other:   make(map[string]string),
	}
}

func (pv *PathVars) Add(k, v string) {
	pv.Other[k] = v
}

func SetupPaths() (*PathVars, error) {
	var (
		pv  PathVars
		err error
		u   *user.User
	)

	u, err = user.Current()
	if err != nil {
		return nil, err
	}

	pv.Home = u.HomeDir

	pv.Current, err = os.Getwd()
	if err != nil {
		return nil, err
	}

	pv.Other = make(map[string]string)

	return &pv, nil
}

func PathToElements(p0 string) (vol string, path []string) {
	vol = filepath.VolumeName(p0)
	p := strings.TrimPrefix(p0, vol)
	p = filepath.Clean(p)

	for p != "" {
		// fmt.Fprintf(os.Stderr, "p: %s\npath: %v\n", p, path)
		p1, base := filepath.Split(p)
		path = append(path, base)
		p1 = filepath.Clean(p1)
		if len(p1) == 1 && (p1[0] == filepath.Separator || p1[0] == '.') {
			path = append(path, p1)
			break
		}

		if p == p1 {
			panic("p == p1")
		}
		p = p1
	}

	if len(path) <= 1 {
		return
	}

	i := 0
	j := len(path) - 1
	for i < j {
		path[i], path[j] = path[j], path[i]
		i++
		j--
	}

	// fmt.Fprintf(os.Stderr, "orig: %s\nvol: %s\npath: %v\n", p0, vol, path)

	return
}

const (
	evBare = iota
	evDollar
	evVar
)

func (pv *PathVars) expandVar(v string) (string, error) {
	state := evBare
	buf := bytes.Buffer{}

	v0 := v
scan_loop:
	for {
		// fmt.Printf("v0 = %s, v = %s, buf = %s\n", v0, v, &buf)
		switch state {
		case evBare:
			i := strings.IndexRune(v, '$')
			if i < 0 {
				break scan_loop
			}
			buf.WriteString(v[:i])
			v = v[i+1:]
			state = evDollar

		case evDollar:
			if len(v) == 0 || v[0] != '{' {
				buf.WriteRune('$')
				// if double $, skip the second
				if v[0] == '$' {
					v = v[1:]
				}
				state = evBare
				continue scan_loop
			}
			state = evVar
			v = v[1:]

		case evVar:
			i := strings.IndexRune(v, '}')
			if i < 0 {
				return "", errors.New("unterminated variable (missing '}')")
			}
			vn := v[:i]
			val, ok := pv.Other[vn]
			if !ok {
				return "", fmt.Errorf("unknown variable '%s'", vn)
			}

			buf.WriteString(val)
			v = v[i+1:]

			state = evBare
		default:
			panic("invalid state")
		}
	}

	if v == v0 {
		return v0, nil
	}

	buf.WriteString(v)
	return buf.String(), nil
}

func (pv *PathVars) ExpandPath(p0 string) (string, error) {
	// Make sure that this is portable - XXX
	p := filepath.Clean(p0)
	if p == "" {
		return p, nil
	}

	if p == "." {
		return pv.Current, nil
	}

	_, elts := PathToElements(p)
	if len(elts) == 0 || (len(elts) == 1 && elts[0] == ".") {
		return p, nil
	}

	for i, e0 := range elts {
		e, err := pv.expandVar(e0)
		if err != nil {
			return "", err
		}

		if e != e0 {
			elts[i] = e
		}
	}

	if elts[0] == "." {
		elts = elts[1:]
	}

	p = filepath.Join(elts...)

	if len(p) > 1 {
		if p[0] == '~' && p[1] == filepath.Separator {
			p = filepath.Join(pv.Home, p[2:])
		}

		if p[0] == '@' && p[1] == filepath.Separator {
			p = filepath.Join(pv.Current, p[2:])
		}
	}

	absP, err := filepath.Abs(p)
	if err != nil {
		log.Printf("error finding absolute path of '%s'", p0)
		return "", err
	}

	return absP, nil
}

func ParseKVFile(in io.Reader, kvFunc func(key, value string) error) error {
	sc := bufio.NewScanner(in)
	for line := 1; sc.Scan(); line++ {
		// remove any comments and strip the remaining
		b := sc.Bytes()
		if ind := bytes.IndexRune(b, '#'); ind >= 0 {
			b = b[:ind]
		}

		b = bytes.TrimSpace(b)
		if len(b) == 0 {
			continue
		}

		f := bytes.Fields(b)
		if len(f) != 2 {
			return fmt.Errorf(
				"invalid config: expected two fields, but found %d on line %d: '%s'",
				len(f), line, b)
		}

		k := string(f[0])
		v := string(f[1])
		if err := kvFunc(k, v); err != nil {
			return fmt.Errorf("invalid key-value pair on line %d: %v",
				line, err)
		}
	}

	return nil
}

func (c *Config) ReadConfigFile(fname string, pv *PathVars) error {
	f, err := os.Open(fname)
	if err != nil {
		return err
	}
	defer f.Close()

	return c.ReadConfig(f, pv)
}

func (c *Config) ReadConfig(r io.Reader, pv *PathVars) error {
	return ParseKVFile(r, func(key, value string) error {
		var err error

		setupPath := func(k, v0 string) string {
			var v string

			if err != nil {
				return ""
			}

			if k != "" {
				return k
			}

			if v, err = pv.ExpandPath(v0); err != nil {
				err = fmt.Errorf("error with key '%s': error expanding path '%s'",
					k, v0)
			}

			return v
		}

		switch key {
		case "dbpath":
			c.DbPath = setupPath(c.DbPath, value)

		case "logdir":
			c.LogDir = setupPath(c.LogDir, value)

		case "auth":
			c.Auth = value

		case "foreman":
			if c.Foreman == "" {
				c.Foreman = value
			}

		case "port":
			p, err := strconv.ParseInt(value, 10, 32)
			if err != nil || p < 1024 || p > 65536 {
				return fmt.Errorf("invalid port: %s", value)
			}
			if c.Port == 0 {
				c.Port = int(p)
			}

		case "foremanlog":
			c.ForemanLogFile = setupPath(c.ForemanLogFile, value)

		case "key":
			// skip for now

		case "keyfile":
			c.KeyFile = setupPath(c.KeyFile, value)

		case "certfile":
			c.CertFile = setupPath(c.CertFile, value)

		case "rootca":
			c.RootCAFile = setupPath(c.RootCAFile, value)

		case "certname":
			if c.CertName == "" {
				c.CertName = value
			}

		default:
			return fmt.Errorf("invalid directive '%s'", key)
		}

		return nil
	})
}
