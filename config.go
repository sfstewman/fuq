package fuq

import (
	"bufio"
	"bytes"
	"crypto/rand"
	"encoding/base64"
	"fmt"
	"io"
	"log"
	"os"
	"os/user"
	"path/filepath"
	"strconv"
	"time"
)

const (
	DefaultSystemConfigFile = "fuq.conf"
	DefaultServerConfigFile = "fuqsrv.conf"
	DefaultConfigPath       = ".fuq"
	DefaultDbFile           = "queue.db"
	DefaultPort             = 5429

	DefaultKeyFile    = "fuq.key"
	DefaultCertFile   = "fuq.crt"
	DefaultRootCAFile = "root.crt"

	CfgDirPerms  = 0700
	CfgFilePerms = 0600
)

type Config struct {
	DbPath  string
	LogDir  string
	Auth    string
	Foreman string
	Port    int

	ForemanLogFile string

	CertName string // server name in TLS certificate

	KeyFile    string
	CertFile   string
	RootCAFile string
}

func (c Config) CheckAuth(cred string) bool {
	return cred == c.Auth
}

func (c Config) CheckClient(client Client) bool {
	return c.CheckAuth(client.Password)
}

func (c *Config) SetupTLS(tlsDir string) {
	if c.KeyFile == "" {
		c.KeyFile = filepath.Join(tlsDir, DefaultKeyFile)
	}

	if c.CertFile == "" {
		c.CertFile = filepath.Join(tlsDir, DefaultCertFile)
	}

	if c.RootCAFile == "" {
		c.RootCAFile = filepath.Join(tlsDir, DefaultRootCAFile)
	}
}

func DefaultConfigDir(u *user.User) string {
	return filepath.Join(u.HomeDir, DefaultConfigPath)
}

func (c *Config) GenerateConfig(fname string, overwrite bool) error {
	flags := os.O_RDWR | os.O_CREATE
	if !overwrite {
		flags = flags | os.O_EXCL
	}

	f, err := os.OpenFile(fname, flags, CfgFilePerms)
	if err != nil {
		if os.IsExist(err) && !overwrite {
			return c.ReadConfig(fname)
		}

		if !os.IsNotExist(err) {
			return err
		}

		cfgDir := filepath.Dir(fname)
		if err := os.MkdirAll(cfgDir, CfgDirPerms); err != nil {
			return fmt.Errorf("error generating config file: %v", err)
		}

		f, err = os.OpenFile(fname, flags, CfgFilePerms)
		if err != nil {
			return fmt.Errorf("error generating config file: %v", err)
		}
	}
	defer f.Close()

	u, err := user.Current()
	if err != nil {
		return fmt.Errorf("error generating config file: %v", err)
	}

	// Rules for the foreman address:
	//   1) if prefixed with '!', use the rest, so "!foo" uses "foo"
	//   2) if "localhost", then use "localhost"
	//   3) otherwise use the hostname
	if len(c.Foreman) > 1 && c.Foreman[0] == '!' {
		c.Foreman = c.Foreman[1:]
	} else if c.Foreman != "localhost" {
		hostname, err := os.Hostname()
		if err != nil {
			return fmt.Errorf("error generating config file: %v", err)
		}

		c.Foreman = hostname
	}

	if c.Port == 0 {
		c.Port = DefaultPort
	}

	cfgDir := DefaultConfigDir(u)

	if c.DbPath == "" {
		c.DbPath = filepath.Join(cfgDir, DefaultDbFile)
		if err := os.MkdirAll(cfgDir, CfgDirPerms); err != nil {
			return fmt.Errorf("error generating config directory '%s': %v",
				cfgDir, err)
		}
	}

	if c.LogDir == "" {
		c.LogDir = filepath.Join(cfgDir, "logs")
	}

	if err := os.MkdirAll(c.LogDir, CfgDirPerms); err != nil {
		return fmt.Errorf("error generating log directory '%s': %v",
			c.LogDir, err)
	}

	if c.Auth == "" {
		buf := [32]byte{}
		if _, err := rand.Read(buf[:]); err != nil {
			return fmt.Errorf("error generating auth string for config file: %s", err)
		}

		c.Auth = base64.RawStdEncoding.EncodeToString(buf[:])
	}

	// c.setupTLS(cfgDir)

	/* FIXME: check errors! */
	fmt.Fprintf(f, "# Autogenerated fuq server configuration file\n")
	fmt.Fprintf(f, "# Generated on: %s\n#\n", time.Now())
	fmt.Fprintf(f, "# DO NOT EDIT BY HAND.  Well, unless you know what you're doing.\n")
	fmt.Fprintf(f, "#\n# NO, SERIOUSLY.  STOP.\n\n")
	fmt.Fprintf(f, "foreman %s\n", c.Foreman)
	fmt.Fprintf(f, "port %d\n", c.Port)
	fmt.Fprintf(f, "logdir %s\n", c.LogDir)
	fmt.Fprintf(f, "dbpath %s\n", c.DbPath)
	fmt.Fprintf(f, "auth %s\n", c.Auth)

	if c.CertName != "" {
		fmt.Fprintf(f, "certname %s\n", c.CertName)
	}

	return nil
}

func DefaultServerConfigPath() string {
	u, err := user.Current()
	if err != nil {
		return ""
	}

	return filepath.Join(u.HomeDir, DefaultConfigPath, DefaultServerConfigFile)
}

func DefaultSystemConfigPath() string {
	u, err := user.Current()
	if err != nil {
		return ""
	}

	return filepath.Join(u.HomeDir, DefaultConfigPath, DefaultSystemConfigFile)
}

type PathVars struct {
	Current string
	Home    string
	Other   map[string]string
}

func NewPathVars(curr, home string) *PathVars {
	return &PathVars{
		Current: curr,
		Home:    home,
		Other:   make(map[string]string),
	}
}

func SetupPaths() (*PathVars, error) {
	var (
		pv  PathVars
		err error
		u   *user.User
	)

	u, err = user.Current()
	if err != nil {
		return nil, err
	}

	pv.Home = u.HomeDir

	pv.Current, err = os.Getwd()
	if err != nil {
		return nil, err
	}

	pv.Other = make(map[string]string)

	return &pv, nil
}

func ExpandHomeDir(p string, pv *PathVars) string {
	// XXX: a bit of a hack to expand ~/ to the user's home directory
	if p[0] == '~' && p[1] == filepath.Separator && pv.Home != "" {
		return filepath.Join(pv.Home, p[2:])
	}

	return p
}

func ExpandPath(p0 string, pv *PathVars) string {
	// Make sure that this is portable - XXX
	p := p0

	switch {
	case p == "":
		return ""

	case p == ".":
		p = pv.Current

	case len(p) <= 1:
		/* nop */

	case p[0] == '~' && p[1] == filepath.Separator:
		p = filepath.Join(pv.Home, p[2:])
	case p[0] == '@' && p[1] == filepath.Separator:
		p = filepath.Join(pv.Current, p[2:])
	}

	// p := ExpandHomeDir(p0, pv)
	absP, err := filepath.Abs(p)
	if err != nil {
		log.Printf("error finding absolute path of '%s'", p0)
		return ""
	}

	return absP
}

func ParseKVFile(in io.Reader, kvFunc func(key, value string) error) error {
	sc := bufio.NewScanner(in)
	for line := 1; sc.Scan(); line++ {
		// remove any comments and strip the remaining
		b := sc.Bytes()
		if ind := bytes.IndexRune(b, '#'); ind >= 0 {
			b = b[:ind]
		}

		b = bytes.TrimSpace(b)
		if len(b) == 0 {
			continue
		}

		f := bytes.Fields(b)
		if len(f) != 2 {
			return fmt.Errorf(
				"invalid config: expected two fields, but found %d on line %d: '%s'",
				len(f), line, b)
		}

		k := string(f[0])
		v := string(f[1])
		if err := kvFunc(k, v); err != nil {
			return fmt.Errorf("invalid key-value pair on line %d: %v",
				line, err)
		}
	}

	return nil
}

func (c *Config) ReadConfig(fname string, pv *PathVars) error {
	f, err := os.Open(fname)
	if err != nil {
		return err
	}
	defer f.Close()

	return ParseKVFile(f, func(key, value string) error {
		switch key {
		case "dbpath":
			if c.DbPath == "" {
				c.DbPath = ExpandPath(value, pv)
			}

		case "logdir":
			if c.LogDir == "" {
				c.LogDir = ExpandPath(value, pv)
			}

		case "auth":
			c.Auth = value

		case "foreman":
			if c.Foreman == "" {
				c.Foreman = value
			}

		case "port":
			p, err := strconv.ParseInt(value, 10, 32)
			if err != nil || p < 1024 || p > 65536 {
				return fmt.Errorf("invalid port: %s", value)
			}
			if c.Port == 0 {
				c.Port = int(p)
			}

		case "foremanlog":
			if c.ForemanLogFile == "" {
				c.ForemanLogFile = ExpandPath(value, pv)
			}

		case "key":
			// skip for now

		case "keyfile":
			if c.KeyFile == "" {
				c.KeyFile = ExpandPath(value, pv)
			}

		case "certfile":
			if c.CertFile == "" {
				c.CertFile = ExpandPath(value, pv)
			}

		case "rootca":
			if c.RootCAFile == "" {
				c.RootCAFile = ExpandPath(value, pv)
			}

		case "certname":
			if c.CertName == "" {
				c.CertName = value
			}

		default:
			return fmt.Errorf("invalid directive '%s'", key)
		}

		return nil
	})
}
