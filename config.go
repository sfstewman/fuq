package fuq

import (
	"bufio"
	"bytes"
	"crypto/rand"
	"encoding/base64"
	"fmt"
	"log"
	"os"
	"os/user"
	"path/filepath"
	"strconv"
	"time"
)

const (
	DefaultSystemConfigFile = "fuq.conf"
	DefaultServerConfigFile = "fuqsrv.conf"
	DefaultConfigPath       = ".fuq"
	DefaultDbFile           = "queue.db"
	DefaultPort             = 5429

	DefaultKeyFile    = "fuq.key"
	DefaultCertFile   = "fuq.crt"
	DefaultRootCAFile = "root.crt"

	CfgDirPerms  = 0700
	CfgFilePerms = 0600
)

type Config struct {
	DbPath  string
	LogDir  string
	Auth    string
	Foreman string
	Port    int

	CertName string // server name in TLS certificate

	KeyFile    string
	CertFile   string
	RootCAFile string
}

func (c Config) CheckAuth(cred string) bool {
	return cred == c.Auth
}

func (c Config) CheckClient(client Client) bool {
	return c.CheckAuth(client.Password)
}

func (c *Config) SetupTLS(tlsDir string) {
	if c.KeyFile == "" {
		c.KeyFile = filepath.Join(tlsDir, DefaultKeyFile)
	}

	if c.CertFile == "" {
		c.CertFile = filepath.Join(tlsDir, DefaultCertFile)
	}

	if c.RootCAFile == "" {
		c.RootCAFile = filepath.Join(tlsDir, DefaultRootCAFile)
	}
}

func DefaultConfigDir(u *user.User) string {
	return filepath.Join(u.HomeDir, DefaultConfigPath)
}

func (c *Config) GenerateConfig(fname string, overwrite bool) error {
	flags := os.O_RDWR | os.O_CREATE
	if !overwrite {
		flags = flags | os.O_EXCL
	}

	f, err := os.OpenFile(fname, flags, CfgFilePerms)
	if err != nil {
		if os.IsExist(err) && !overwrite {
			return c.ReadConfig(fname)
		}

		if !os.IsNotExist(err) {
			return err
		}

		cfgDir := filepath.Dir(fname)
		if err := os.MkdirAll(cfgDir, CfgDirPerms); err != nil {
			return fmt.Errorf("error generating config file: %v", err)
		}

		f, err = os.OpenFile(fname, flags, CfgFilePerms)
		if err != nil {
			return fmt.Errorf("error generating config file: %v", err)
		}
	}
	defer f.Close()

	u, err := user.Current()
	if err != nil {
		return fmt.Errorf("error generating config file: %v", err)
	}

	hostname, err := os.Hostname()
	if err != nil {
		return fmt.Errorf("error generating config file: %v", err)
	}

	c.Foreman = hostname
	if c.Port == 0 {
		c.Port = DefaultPort
	}

	cfgDir := DefaultConfigDir(u)

	if c.DbPath == "" {
		c.DbPath = filepath.Join(cfgDir, DefaultDbFile)
		if err := os.MkdirAll(cfgDir, CfgDirPerms); err != nil {
			return fmt.Errorf("error generating config directory '%s': %v",
				cfgDir, err)
		}
	}

	if c.LogDir == "" {
		c.LogDir = filepath.Join(cfgDir, "logs")
	}

	if err := os.MkdirAll(c.LogDir, CfgDirPerms); err != nil {
		return fmt.Errorf("error generating log directory '%s': %v",
			c.LogDir, err)
	}

	if c.Auth == "" {
		buf := [32]byte{}
		if _, err := rand.Read(buf[:]); err != nil {
			return fmt.Errorf("error generating auth string for config file: %s", err)
		}

		c.Auth = base64.RawStdEncoding.EncodeToString(buf[:])
	}

	// c.setupTLS(cfgDir)

	/* FIXME: check errors! */
	fmt.Fprintf(f, "# Autogenerated fuq server configuration file\n")
	fmt.Fprintf(f, "# Generated on: %s\n#\n", time.Now())
	fmt.Fprintf(f, "# DO NOT EDIT BY HAND.  Well, unless you know what you're doing.\n")
	fmt.Fprintf(f, "#\n# NO, SERIOUSLY.  STOP.\n\n")
	fmt.Fprintf(f, "foreman %s\n", c.Foreman)
	fmt.Fprintf(f, "port %d\n", c.Port)
	fmt.Fprintf(f, "logdir %s\n", c.LogDir)
	fmt.Fprintf(f, "dbpath %s\n", c.DbPath)
	fmt.Fprintf(f, "auth %s\n", c.Auth)

	if c.CertName != "" {
		fmt.Fprintf(f, "certname %s\n", c.CertName)
	}

	return nil
}

func DefaultServerConfigPath() string {
	u, err := user.Current()
	if err != nil {
		return ""
	}

	return filepath.Join(u.HomeDir, DefaultConfigPath, DefaultServerConfigFile)
}

func DefaultSystemConfigPath() string {
	u, err := user.Current()
	if err != nil {
		return ""
	}

	return filepath.Join(u.HomeDir, DefaultConfigPath, DefaultSystemConfigFile)
}

func ExpandHomeDir(p string) string {
	// XXX: a bit of a hack to expand ~/ to the user's home directory
	if p[0] == '~' && p[1] == filepath.Separator {
		u, err := user.Current()
		if err != nil {
			return p
		}

		return filepath.Join(u.HomeDir, p[2:])
	}

	return p
}

func ExpandPath(p0 string) string {
	p := ExpandHomeDir(p0)
	absP, err := filepath.Abs(p)
	if err != nil {
		log.Printf("error finding absolute path of '%s'", p0)
		return ""
	}

	return absP
}

func (c *Config) ReadConfig(fname string) error {
	f, err := os.Open(fname)
	if err != nil {
		return err
	}
	defer f.Close()

	sc := bufio.NewScanner(f)
	for line := 1; sc.Scan(); line++ {
		// remove any comments and strip the remaining
		b := sc.Bytes()
		if ind := bytes.IndexRune(b, '#'); ind >= 0 {
			b = b[:ind]
		}

		b = bytes.TrimSpace(b)
		if len(b) == 0 {
			continue
		}

		f := bytes.Fields(b)
		if len(f) != 2 {
			return fmt.Errorf(
				"invalid config: expected two fields, but found %d on line %d: '%s'",
				len(f), line, b)
		}
		switch cmd := string(f[0]); cmd {
		case "dbpath":
			if c.DbPath == "" {
				c.DbPath = ExpandPath(string(f[1]))
			}
		case "logdir":
			if c.LogDir == "" {
				c.LogDir = ExpandPath(string(f[1]))
			}
		case "auth":
			c.Auth = string(f[1])
		case "foreman":
			if c.Foreman == "" {
				c.Foreman = string(f[1])
			}
		case "port":
			s := string(f[1])
			p, err := strconv.ParseInt(s, 10, 32)
			if err != nil || p < 1024 || p > 65536 {
				return fmt.Errorf("invalid config: invalid port on line %d: %s",
					line, s)
			}
			if c.Port == 0 {
				c.Port = int(p)
			}

		case "key":
			// skip for now

		case "keyfile":
			if c.KeyFile == "" {
				c.KeyFile = ExpandPath(string(f[1]))
			}
		case "certfile":
			if c.CertFile == "" {
				c.CertFile = ExpandPath(string(f[1]))
			}
		case "rootca":
			if c.RootCAFile == "" {
				c.RootCAFile = ExpandPath(string(f[1]))
			}

		case "certname":
			if c.CertName == "" {
				c.CertName = string(f[1])
			}
		default:
			return fmt.Errorf("invalid config: invalid directive on line %d: %s",
				line, cmd)
		}
	}

	return nil

}
